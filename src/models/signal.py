"""
Trading signal model for XAUUSD Gold Trading System.

Represents a complete trading signal generated by the SMC analysis engine
with all necessary information for trade execution.
"""

from dataclasses import dataclass, field
from datetime import datetime
from decimal import Decimal
from typing import List, Optional, Literal
from enum import Enum


class SignalStatus(Enum):
    """Signal status enumeration."""
    ACTIVE = "ACTIVE"
    FILLED = "FILLED"
    CANCELLED = "CANCELLED"
    EXPIRED = "EXPIRED"


class SessionType(Enum):
    """Trading session enumeration."""
    ASIAN = "ASIAN"
    LONDON = "LONDON"
    NY = "NY"
    NY_OVERLAP = "NY_OVERLAP"


@dataclass
class TradingSignal:
    """
    Complete trading signal with SMC context and risk management.
    
    Contains all information needed to execute and manage a trade
    based on Smart Money Concepts analysis.
    """
    # Basic signal information
    signal_id: str
    direction: Literal["BUY", "SELL"]
    entry_price: Decimal
    stop_loss: Decimal
    take_profit_1: Decimal  # 50% position
    take_profit_2: Decimal  # 50% position
    risk_reward_ratio: float
    position_size: Decimal
    risk_percentage: float
    setup_type: str  # "FVG+OB", "LIQUIDITY_SWEEP", "BREAKOUT", etc.
    market_structure: str  # "BOS", "CHoCH", "RANGE"
    confidence_score: float  # 0.0 to 1.0

    # Fields with default values
    instrument: str = "XAUUSD"
    confluence_factors: List[str] = field(default_factory=list)
    h4_context: Optional[str] = None
    h1_context: Optional[str] = None
    m15_context: Optional[str] = None
    session: SessionType = SessionType.LONDON
    created_at: datetime = field(default_factory=datetime.utcnow)
    updated_at: datetime = field(default_factory=datetime.utcnow)
    expires_at: Optional[datetime] = None
    status: SignalStatus = SignalStatus.ACTIVE
    telegram_message_id: Optional[int] = None
    notes: Optional[str] = None
    
    def __post_init__(self):
        """Validate signal after initialization."""
        # Validate direction
        if self.direction not in ["BUY", "SELL"]:
            raise ValueError(f"Direction must be 'BUY' or 'SELL', got {self.direction}")
        
        # Validate price levels
        if self.direction == "BUY" and self.entry_price <= self.stop_loss:
            raise ValueError("For BUY signals, entry price must be above stop loss")
        
        if self.direction == "SELL" and self.entry_price >= self.stop_loss:
            raise ValueError("For SELL signals, entry price must be below stop loss")
        
        # Validate take profits
        if self.direction == "BUY":
            if not (self.take_profit_1 > self.entry_price > self.stop_loss):
                raise ValueError("For BUY: TP1 > Entry > SL")
            if not (self.take_profit_2 > self.take_profit_1):
                raise ValueError("For BUY: TP2 > TP1")
        else:  # SELL
            if not (self.take_profit_1 < self.entry_price < self.stop_loss):
                raise ValueError("For SELL: TP1 < Entry < SL")
            if not (self.take_profit_2 < self.take_profit_1):
                raise ValueError("For SELL: TP2 < TP1")
        
        # Validate confidence
        if not 0 <= self.confidence_score <= 1:
            raise ValueError(f"Confidence score must be between 0 and 1, got {self.confidence_score}")
        
        # Validate risk percentage
        if not 0 < self.risk_percentage <= 5:
            raise ValueError(f"Risk percentage should be between 0 and 5, got {self.risk_percentage}")
        
        # Validate position size
        if self.position_size <= 0:
            raise ValueError(f"Position size must be positive, got {self.position_size}")
    
    @property
    def is_buy(self) -> bool:
        """Check if this is a buy signal."""
        return self.direction == "BUY"
    
    @property
    def is_sell(self) -> bool:
        """Check if this is a sell signal."""
        return self.direction == "SELL"
    
    @property
    def risk_pips(self) -> Decimal:
        """Calculate risk in pips."""
        if self.is_buy:
            return self.entry_price - self.stop_loss
        else:
            return self.stop_loss - self.entry_price
    
    @property
    def reward_1_pips(self) -> Decimal:
        """Calculate TP1 reward in pips."""
        if self.is_buy:
            return self.take_profit_1 - self.entry_price
        else:
            return self.entry_price - self.take_profit_1
    
    @property
    def reward_2_pips(self) -> Decimal:
        """Calculate TP2 reward in pips."""
        if self.is_buy:
            return self.take_profit_2 - self.entry_price
        else:
            return self.entry_price - self.take_profit_2
    
    @property
    def rr_ratio_1(self) -> float:
        """Calculate risk:reward ratio for TP1."""
        return float(self.reward_1_pips / self.risk_pips)
    
    @property
    def rr_ratio_2(self) -> float:
        """Calculate risk:reward ratio for TP2."""
        return float(self.reward_2_pips / self.risk_pips)
    
    @property
    def age_minutes(self) -> float:
        """Calculate signal age in minutes."""
        return (datetime.utcnow() - self.created_at).total_seconds() / 60
    
    @property
    def is_expired(self) -> bool:
        """Check if signal has expired."""
        if self.expires_at is None:
            return False
        return datetime.utcnow() > self.expires_at
    
    def update_status(self, status: SignalStatus):
        """Update signal status and timestamp."""
        self.status = status
        self.updated_at = datetime.utcnow()
    
    def is_price_near_entry(self, current_price: Decimal, tolerance_pips: Decimal = Decimal('5')) -> bool:
        """
        Check if current price is near entry level.
        
        Args:
            current_price: Current market price
            tolerance_pips: Tolerance in pips
            
        Returns:
            True if price is within tolerance of entry
        """
        tolerance = tolerance_pips / Decimal('10000')  # Convert pips to price
        return abs(current_price - self.entry_price) <= tolerance
    
    def is_price_at_risk_level(self, current_price: Decimal, tolerance_pips: Decimal = Decimal('2')) -> bool:
        """
        Check if price is at or near stop loss level.
        
        Args:
            current_price: Current market price
            tolerance_pips: Tolerance in pips
            
        Returns:
            True if price is within tolerance of stop loss
        """
        tolerance = tolerance_pips / Decimal('10000')
        return abs(current_price - self.stop_loss) <= tolerance
    
    def calculate_partial_close_size(self, percentage: float) -> Decimal:
        """
        Calculate position size for partial close.
        
        Args:
            percentage: Percentage to close (0.0 to 1.0)
            
        Returns:
            Position size to close
        """
        return self.position_size * Decimal(str(percentage))
    
    def to_dict(self) -> dict:
        """Convert signal to dictionary representation."""
        return {
            'signal_id': self.signal_id,
            'instrument': self.instrument,
            'direction': self.direction,
            'entry_price': float(self.entry_price),
            'stop_loss': float(self.stop_loss),
            'take_profit_1': float(self.take_profit_1),
            'take_profit_2': float(self.take_profit_2),
            'risk_reward_ratio': self.risk_reward_ratio,
            'position_size': float(self.position_size),
            'risk_percentage': self.risk_percentage,
            'setup_type': self.setup_type,
            'market_structure': self.market_structure,
            'confluence_factors': self.confluence_factors,
            'confidence_score': self.confidence_score,
            'h4_context': self.h4_context,
            'h1_context': self.h1_context,
            'm15_context': self.m15_context,
            'session': self.session.value,
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat(),
            'expires_at': self.expires_at.isoformat() if self.expires_at else None,
            'status': self.status.value,
            'telegram_message_id': self.telegram_message_id,
            'notes': self.notes,
            'risk_pips': float(self.risk_pips),
            'reward_1_pips': float(self.reward_1_pips),
            'reward_2_pips': float(self.reward_2_pips),
            'rr_ratio_1': self.rr_ratio_1,
            'rr_ratio_2': self.rr_ratio_2,
            'age_minutes': self.age_minutes
        }
    
    @classmethod
    def from_dict(cls, data: dict) -> 'TradingSignal':
        """Create signal from dictionary representation."""
        # Handle enum conversions
        session = SessionType(data['session']) if isinstance(data.get('session'), str) else data.get('session')
        status = SignalStatus(data['status']) if isinstance(data.get('status'), str) else data.get('status')
        
        # Convert timestamps
        created_at = datetime.fromisoformat(data['created_at']) if data.get('created_at') else datetime.utcnow()
        updated_at = datetime.fromisoformat(data['updated_at']) if data.get('updated_at') else datetime.utcnow()
        expires_at = datetime.fromisoformat(data['expires_at']) if data.get('expires_at') else None
        
        return cls(
            signal_id=data['signal_id'],
            instrument=data.get('instrument', 'XAUUSD'),
            direction=data['direction'],
            entry_price=Decimal(str(data['entry_price'])),
            stop_loss=Decimal(str(data['stop_loss'])),
            take_profit_1=Decimal(str(data['take_profit_1'])),
            take_profit_2=Decimal(str(data['take_profit_2'])),
            risk_reward_ratio=data['risk_reward_ratio'],
            position_size=Decimal(str(data['position_size'])),
            risk_percentage=data['risk_percentage'],
            setup_type=data['setup_type'],
            market_structure=data['market_structure'],
            confluence_factors=data.get('confluence_factors', []),
            confidence_score=data['confidence_score'],
            h4_context=data.get('h4_context'),
            h1_context=data.get('h1_context'),
            m15_context=data.get('m15_context'),
            session=session,
            created_at=created_at,
            updated_at=updated_at,
            expires_at=expires_at,
            status=status,
            telegram_message_id=data.get('telegram_message_id'),
            notes=data.get('notes')
        )