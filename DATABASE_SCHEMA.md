# Database Schema Documentation

## Overview

The XAUUSD Gold Trading System uses PostgreSQL as its primary database for storing trading signals, trade history, performance metrics, and system configuration. This document provides a comprehensive overview of the database schema, relationships, and usage patterns.

## Database Information

- **Database Name**: `xauusd_trading`
- **DBMS**: PostgreSQL 16+
- **Character Set**: UTF8
- **Timezone**: UTC
- **Connection Pool**: 20 connections (configurable)

## Schema Diagram

```
┌─────────────────┐
│    signals      │
│─────────────────│
│ signal_id (PK)  │◄─────┐
│ instrument      │      │
│ direction       │      │
│ entry_price     │      │
│ stop_loss       │      │
│ take_profit_1   │      │
│ take_profit_2   │      │
│ setup_type      │      │
│ confidence      │      │
│ created_at      │      │
│ status          │      │
└─────────────────┘      │
                         │
                         │ 1:N
                         │
┌─────────────────┐      │
│     trades      │      │
│─────────────────│      │
│ trade_id (PK)   │      │
│ signal_id (FK)  │──────┘
│ entry_time      │
│ exit_time       │
│ entry_price     │
│ exit_price      │
│ profit_loss     │
│ status          │
│ partial_closes  │
└─────────────────┘
         │
         │ N:1
         │
         ▼
┌─────────────────────┐
│ performance_metrics │
│─────────────────────│
│ metric_id (PK)      │
│ instrument          │
│ date                │
│ total_signals       │
│ winning_trades      │
│ losing_trades       │
│ win_rate            │
│ average_rr          │
│ total_pips          │
└─────────────────────┘

┌─────────────────┐
│ price_history   │
│─────────────────│
│ id (PK)         │
│ instrument      │
│ timeframe       │
│ timestamp       │
│ open            │
│ high            │
│ low             │
│ close           │
│ volume          │
└─────────────────┘

┌─────────────────┐
│ system_config   │
│─────────────────│
│ config_id (PK)  │
│ key             │
│ value           │
│ category        │
│ updated_at      │
└─────────────────┘

┌─────────────────┐
│ audit_log       │
│─────────────────│
│ log_id (PK)     │
│ event_type      │
│ entity_type     │
│ entity_id       │
│ user_id         │
│ changes         │
│ timestamp       │
└─────────────────┘
```

## Table Definitions

### 1. signals

Stores all trading signals generated by the SMC analysis engine.

```sql
CREATE TABLE signals (
    -- Primary Key
    signal_id VARCHAR(50) PRIMARY KEY,
    
    -- Instrument Information
    instrument VARCHAR(20) NOT NULL,
    
    -- Trade Direction
    direction VARCHAR(4) NOT NULL CHECK (direction IN ('BUY', 'SELL')),
    
    -- Price Levels
    entry_price DECIMAL(10, 5) NOT NULL,
    stop_loss DECIMAL(10, 5) NOT NULL,
    take_profit_1 DECIMAL(10, 5),
    take_profit_2 DECIMAL(10, 5),
    
    -- Risk Management
    risk_reward_ratio DECIMAL(5, 2),
    position_size DECIMAL(8, 2),
    risk_percentage DECIMAL(5, 2),
    
    -- SMC Context
    setup_type VARCHAR(100),
    market_structure VARCHAR(50),
    confluence_factors JSONB,
    confidence_score DECIMAL(3, 2) CHECK (confidence_score >= 0 AND confidence_score <= 1),
    
    -- Timeframe Analysis
    h4_context TEXT,
    h1_context TEXT,
    m15_context TEXT,
    
    -- Session Information
    session VARCHAR(20),
    
    -- Metadata
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status VARCHAR(20) DEFAULT 'ACTIVE' CHECK (status IN ('ACTIVE', 'FILLED', 'CANCELLED', 'EXPIRED')),
    
    -- Telegram
    telegram_message_id BIGINT,
    
    -- Indexes
    CONSTRAINT signals_entry_sl_check CHECK (
        (direction = 'BUY' AND entry_price > stop_loss) OR
        (direction = 'SELL' AND entry_price < stop_loss)
    )
);

-- Indexes
CREATE INDEX idx_signals_instrument_status ON signals(instrument, status);
CREATE INDEX idx_signals_created_at ON signals(created_at DESC);
CREATE INDEX idx_signals_confidence ON signals(confidence_score DESC);
CREATE INDEX idx_signals_session ON signals(session);
CREATE INDEX idx_signals_setup_type ON signals(setup_type);

-- Full-text search on context
CREATE INDEX idx_signals_context_search ON signals USING gin(
    to_tsvector('english', 
        COALESCE(h4_context, '') || ' ' || 
        COALESCE(h1_context, '') || ' ' || 
        COALESCE(m15_context, '')
    )
);
```

**Sample Data:**
```sql
INSERT INTO signals VALUES (
    'XAU_20240105_001',
    'XAUUSD',
    'BUY',
    2045.50,
    2040.00,
    2055.00,
    2065.00,
    3.50,
    0.50,
    1.0,
    'FVG + Order Block',
    'BOS',
    '["Bullish FVG", "Strong OB", "Liquidity Sweep"]'::jsonb,
    0.85,
    'Uptrend confirmed, HH and HL pattern',
    'Bullish order block at 2042, FVG zone 2043-2046',
    'Price retracing to OB, waiting for rejection',
    'LONDON',
    '2024-01-05 14:30:00',
    '2024-01-05 14:30:00',
    'ACTIVE',
    123456789
);
```

### 2. trades

Stores actual trade execution and results.

```sql
CREATE TABLE trades (
    -- Primary Key
    trade_id SERIAL PRIMARY KEY,
    
    -- Foreign Key
    signal_id VARCHAR(50) REFERENCES signals(signal_id) ON DELETE CASCADE,
    
    -- Trade Timing
    entry_time TIMESTAMP,
    exit_time TIMESTAMP,
    duration_minutes INTEGER GENERATED ALWAYS AS (
        EXTRACT(EPOCH FROM (exit_time - entry_time)) / 60
    ) STORED,
    
    -- Price Information
    entry_price DECIMAL(10, 5),
    exit_price DECIMAL(10, 5),
    highest_price DECIMAL(10, 5),
    lowest_price DECIMAL(10, 5),
    
    -- Profit/Loss
    profit_loss DECIMAL(10, 2),
    profit_loss_pips DECIMAL(8, 2),
    profit_loss_percentage DECIMAL(6, 2),
    
    -- Position Information
    position_size DECIMAL(8, 2),
    
    -- Trade Status
    status VARCHAR(20) CHECK (status IN (
        'PENDING', 'OPEN', 'CLOSED', 'CANCELLED', 'STOPPED_OUT'
    )),
    
    -- Partial Closes
    partial_closes JSONB DEFAULT '[]'::jsonb,
    tp1_hit BOOLEAN DEFAULT FALSE,
    tp2_hit BOOLEAN DEFAULT FALSE,
    sl_hit BOOLEAN DEFAULT FALSE,
    breakeven_moved BOOLEAN DEFAULT FALSE,
    
    -- Exit Reason
    exit_reason VARCHAR(50),
    
    -- Metadata
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Indexes
CREATE INDEX idx_trades_signal_id ON trades(signal_id);
CREATE INDEX idx_trades_status ON trades(status);
CREATE INDEX idx_trades_entry_time ON trades(entry_time DESC);
CREATE INDEX idx_trades_profit_loss ON trades(profit_loss DESC);
CREATE INDEX idx_trades_duration ON trades(duration_minutes);

-- Partial index for open trades
CREATE INDEX idx_trades_open ON trades(entry_time) WHERE status = 'OPEN';
```

**Sample Data:**
```sql
INSERT INTO trades (
    signal_id, entry_time, exit_time, entry_price, exit_price,
    highest_price, lowest_price, profit_loss, profit_loss_pips,
    position_size, status, partial_closes, tp1_hit, tp2_hit,
    exit_reason
) VALUES (
    'XAU_20240105_001',
    '2024-01-05 14:35:00',
    '2024-01-05 16:20:00',
    2045.50,
    2055.00,
    2056.20,
    2044.80,
    475.00,
    95.0,
    0.50,
    'CLOSED',
    '[
        {"time": "2024-01-05 15:45:00", "price": 2055.00, "size": 0.25, "profit": 237.50},
        {"time": "2024-01-05 16:20:00", "price": 2055.00, "size": 0.25, "profit": 237.50}
    ]'::jsonb,
    TRUE,
    TRUE,
    'TP2_HIT'
);
```

### 3. performance_metrics

Aggregated performance statistics by instrument and date.

```sql
CREATE TABLE performance_metrics (
    -- Primary Key
    metric_id SERIAL PRIMARY KEY,
    
    -- Instrument and Date
    instrument VARCHAR(20) NOT NULL,
    date DATE NOT NULL,
    
    -- Signal Statistics
    total_signals INTEGER DEFAULT 0,
    signals_filled INTEGER DEFAULT 0,
    signals_cancelled INTEGER DEFAULT 0,
    
    -- Trade Statistics
    total_trades INTEGER DEFAULT 0,
    winning_trades INTEGER DEFAULT 0,
    losing_trades INTEGER DEFAULT 0,
    breakeven_trades INTEGER DEFAULT 0,
    
    -- Performance Metrics
    win_rate DECIMAL(5, 2),
    average_rr DECIMAL(5, 2),
    profit_factor DECIMAL(6, 2),
    
    -- Profit/Loss
    total_pips DECIMAL(10, 2),
    total_profit_loss DECIMAL(12, 2),
    largest_win DECIMAL(10, 2),
    largest_loss DECIMAL(10, 2),
    average_win DECIMAL(10, 2),
    average_loss DECIMAL(10, 2),
    
    -- Risk Metrics
    max_drawdown DECIMAL(10, 2),
    max_drawdown_percentage DECIMAL(6, 2),
    sharpe_ratio DECIMAL(6, 3),
    
    -- Trade Duration
    average_trade_duration_minutes INTEGER,
    
    -- Metadata
    calculated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- Unique constraint
    UNIQUE(instrument, date)
);

-- Indexes
CREATE INDEX idx_performance_instrument_date ON performance_metrics(instrument, date DESC);
CREATE INDEX idx_performance_win_rate ON performance_metrics(win_rate DESC);
CREATE INDEX idx_performance_profit_loss ON performance_metrics(total_profit_loss DESC);
```

**Sample Data:**
```sql
INSERT INTO performance_metrics (
    instrument, date, total_signals, total_trades,
    winning_trades, losing_trades, win_rate, average_rr,
    total_pips, total_profit_loss, calculated_at
) VALUES (
    'XAUUSD',
    '2024-01-05',
    5,
    4,
    3,
    1,
    75.00,
    2.80,
    185.50,
    927.50,
    '2024-01-05 23:59:59'
);
```

### 4. price_history

Historical price data for backtesting and analysis.

```sql
CREATE TABLE price_history (
    -- Primary Key
    id SERIAL PRIMARY KEY,
    
    -- Instrument and Timeframe
    instrument VARCHAR(20) NOT NULL,
    timeframe VARCHAR(10) NOT NULL CHECK (timeframe IN ('M1', 'M5', 'M15', 'M30', 'H1', 'H4', 'D1')),
    
    -- Timestamp
    timestamp TIMESTAMP NOT NULL,
    
    -- OHLC Data
    open DECIMAL(10, 5) NOT NULL,
    high DECIMAL(10, 5) NOT NULL,
    low DECIMAL(10, 5) NOT NULL,
    close DECIMAL(10, 5) NOT NULL,
    
    -- Volume
    volume BIGINT,
    tick_volume BIGINT,
    
    -- Spread
    spread INTEGER,
    
    -- Metadata
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- Unique constraint
    UNIQUE(instrument, timeframe, timestamp),
    
    -- Data validation
    CHECK (high >= low),
    CHECK (high >= open),
    CHECK (high >= close),
    CHECK (low <= open),
    CHECK (low <= close)
);

-- Indexes
CREATE INDEX idx_price_history_instrument_timeframe_timestamp 
    ON price_history(instrument, timeframe, timestamp DESC);
CREATE INDEX idx_price_history_timestamp ON price_history(timestamp DESC);

-- Partition by month for better performance
CREATE TABLE price_history_2024_01 PARTITION OF price_history
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
```

### 5. system_config

System configuration and parameters.

```sql
CREATE TABLE system_config (
    -- Primary Key
    config_id SERIAL PRIMARY KEY,
    
    -- Configuration Key
    key VARCHAR(100) NOT NULL UNIQUE,
    
    -- Configuration Value
    value TEXT NOT NULL,
    
    -- Category
    category VARCHAR(50) NOT NULL,
    
    -- Description
    description TEXT,
    
    -- Data Type
    data_type VARCHAR(20) CHECK (data_type IN ('string', 'integer', 'float', 'boolean', 'json')),
    
    -- Validation
    validation_rule TEXT,
    
    -- Metadata
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_by VARCHAR(50)
);

-- Indexes
CREATE INDEX idx_system_config_category ON system_config(category);
CREATE INDEX idx_system_config_key ON system_config(key);
```

**Sample Data:**
```sql
INSERT INTO system_config (key, value, category, description, data_type) VALUES
    ('risk_per_trade', '1.0', 'risk_management', 'Risk percentage per trade', 'float'),
    ('max_concurrent_trades', '2', 'risk_management', 'Maximum concurrent trades', 'integer'),
    ('min_risk_reward', '2.0', 'risk_management', 'Minimum risk:reward ratio', 'float'),
    ('fvg_min_size_pips', '5', 'smc_parameters', 'Minimum FVG size in pips', 'integer'),
    ('ob_lookback_candles', '20', 'smc_parameters', 'Order block lookback period', 'integer');
```

### 6. audit_log

Audit trail for all system changes and actions.

```sql
CREATE TABLE audit_log (
    -- Primary Key
    log_id SERIAL PRIMARY KEY,
    
    -- Event Information
    event_type VARCHAR(50) NOT NULL,
    entity_type VARCHAR(50) NOT NULL,
    entity_id VARCHAR(100),
    
    -- User Information
    user_id VARCHAR(50),
    ip_address INET,
    
    -- Changes
    old_values JSONB,
    new_values JSONB,
    changes JSONB,
    
    -- Additional Context
    context JSONB,
    
    -- Timestamp
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Indexes
CREATE INDEX idx_audit_log_timestamp ON audit_log(timestamp DESC);
CREATE INDEX idx_audit_log_event_type ON audit_log(event_type);
CREATE INDEX idx_audit_log_entity ON audit_log(entity_type, entity_id);
CREATE INDEX idx_audit_log_user ON audit_log(user_id);
```

## Views

### v_active_signals

View of currently active signals with trade information.

```sql
CREATE VIEW v_active_signals AS
SELECT 
    s.signal_id,
    s.instrument,
    s.direction,
    s.entry_price,
    s.stop_loss,
    s.take_profit_1,
    s.take_profit_2,
    s.risk_reward_ratio,
    s.setup_type,
    s.confidence_score,
    s.session,
    s.created_at,
    t.trade_id,
    t.status AS trade_status,
    t.entry_time,
    t.profit_loss,
    t.profit_loss_pips
FROM signals s
LEFT JOIN trades t ON s.signal_id = t.signal_id
WHERE s.status = 'ACTIVE'
ORDER BY s.created_at DESC;
```

### v_daily_performance

Daily performance summary.

```sql
CREATE VIEW v_daily_performance AS
SELECT 
    instrument,
    DATE(entry_time) AS trade_date,
    COUNT(*) AS total_trades,
    SUM(CASE WHEN profit_loss > 0 THEN 1 ELSE 0 END) AS winning_trades,
    SUM(CASE WHEN profit_loss < 0 THEN 1 ELSE 0 END) AS losing_trades,
    ROUND(
        (SUM(CASE WHEN profit_loss > 0 THEN 1 ELSE 0 END)::DECIMAL / COUNT(*)) * 100, 
        2
    ) AS win_rate,
    SUM(profit_loss) AS total_profit_loss,
    SUM(profit_loss_pips) AS total_pips,
    AVG(CASE WHEN profit_loss > 0 THEN profit_loss END) AS avg_win,
    AVG(CASE WHEN profit_loss < 0 THEN profit_loss END) AS avg_loss
FROM trades
WHERE status = 'CLOSED'
GROUP BY instrument, DATE(entry_time)
ORDER BY trade_date DESC;
```

### v_signal_performance

Signal performance analysis.

```sql
CREATE VIEW v_signal_performance AS
SELECT 
    s.setup_type,
    s.session,
    COUNT(DISTINCT s.signal_id) AS total_signals,
    COUNT(t.trade_id) AS total_trades,
    SUM(CASE WHEN t.profit_loss > 0 THEN 1 ELSE 0 END) AS winning_trades,
    ROUND(
        (SUM(CASE WHEN t.profit_loss > 0 THEN 1 ELSE 0 END)::DECIMAL / 
         NULLIF(COUNT(t.trade_id), 0)) * 100, 
        2
    ) AS win_rate,
    AVG(s.confidence_score) AS avg_confidence,
    AVG(t.profit_loss) AS avg_profit_loss,
    AVG(t.profit_loss_pips) AS avg_pips
FROM signals s
LEFT JOIN trades t ON s.signal_id = t.signal_id AND t.status = 'CLOSED'
GROUP BY s.setup_type, s.session
ORDER BY win_rate DESC;
```

## Functions

### calculate_performance_metrics

Function to calculate and update performance metrics.

```sql
CREATE OR REPLACE FUNCTION calculate_performance_metrics(
    p_instrument VARCHAR,
    p_date DATE
) RETURNS VOID AS $$
DECLARE
    v_total_trades INTEGER;
    v_winning_trades INTEGER;
    v_losing_trades INTEGER;
    v_total_pips DECIMAL;
    v_total_pl DECIMAL;
BEGIN
    -- Calculate metrics
    SELECT 
        COUNT(*),
        SUM(CASE WHEN profit_loss > 0 THEN 1 ELSE 0 END),
        SUM(CASE WHEN profit_loss < 0 THEN 1 ELSE 0 END),
        SUM(profit_loss_pips),
        SUM(profit_loss)
    INTO 
        v_total_trades,
        v_winning_trades,
        v_losing_trades,
        v_total_pips,
        v_total_pl
    FROM trades t
    JOIN signals s ON t.signal_id = s.signal_id
    WHERE s.instrument = p_instrument
        AND DATE(t.entry_time) = p_date
        AND t.status = 'CLOSED';
    
    -- Insert or update metrics
    INSERT INTO performance_metrics (
        instrument, date, total_trades, winning_trades, losing_trades,
        win_rate, total_pips, total_profit_loss
    ) VALUES (
        p_instrument, p_date, v_total_trades, v_winning_trades, v_losing_trades,
        CASE WHEN v_total_trades > 0 
            THEN (v_winning_trades::DECIMAL / v_total_trades) * 100 
            ELSE 0 
        END,
        v_total_pips, v_total_pl
    )
    ON CONFLICT (instrument, date) 
    DO UPDATE SET
        total_trades = EXCLUDED.total_trades,
        winning_trades = EXCLUDED.winning_trades,
        losing_trades = EXCLUDED.losing_trades,
        win_rate = EXCLUDED.win_rate,
        total_pips = EXCLUDED.total_pips,
        total_profit_loss = EXCLUDED.total_profit_loss,
        calculated_at = CURRENT_TIMESTAMP;
END;
$$ LANGUAGE plpgsql;
```

## Triggers

### update_timestamp

Automatically update `updated_at` timestamp.

```sql
CREATE OR REPLACE FUNCTION update_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER signals_update_timestamp
    BEFORE UPDATE ON signals
    FOR EACH ROW
    EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER trades_update_timestamp
    BEFORE UPDATE ON trades
    FOR EACH ROW
    EXECUTE FUNCTION update_timestamp();
```

### audit_changes

Log all changes to audit_log.

```sql
CREATE OR REPLACE FUNCTION audit_changes()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'UPDATE' THEN
        INSERT INTO audit_log (
            event_type, entity_type, entity_id,
            old_values, new_values
        ) VALUES (
            'UPDATE',
            TG_TABLE_NAME,
            COALESCE(NEW.signal_id, NEW.trade_id::TEXT),
            row_to_json(OLD),
            row_to_json(NEW)
        );
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO audit_log (
            event_type, entity_type, entity_id,
            old_values
        ) VALUES (
            'DELETE',
            TG_TABLE_NAME,
            COALESCE(OLD.signal_id, OLD.trade_id::TEXT),
            row_to_json(OLD)
        );
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER signals_audit
    AFTER UPDATE OR DELETE ON signals
    FOR EACH ROW
    EXECUTE FUNCTION audit_changes();
```

## Maintenance

### Backup Strategy

```sql
-- Daily backup
pg_dump -U trader -d xauusd_trading -F c -f backup_$(date +%Y%m%d).dump

-- Restore from backup
pg_restore -U trader -d xauusd_trading -c backup_20240105.dump
```

### Vacuum and Analyze

```sql
-- Regular maintenance
VACUUM ANALYZE signals;
VACUUM ANALYZE trades;
VACUUM ANALYZE performance_metrics;

-- Full vacuum (requires downtime)
VACUUM FULL;
```

### Index Maintenance

```sql
-- Rebuild indexes
REINDEX TABLE signals;
REINDEX TABLE trades;

-- Check index usage
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
ORDER BY idx_scan ASC;
```

## Performance Optimization

### Query Optimization Tips

1. **Use appropriate indexes**
2. **Avoid SELECT ***
3. **Use EXPLAIN ANALYZE**
4. **Partition large tables**
5. **Use connection pooling**

### Example Optimized Queries

```sql
-- Get recent signals with trade info (optimized)
SELECT 
    s.signal_id,
    s.instrument,
    s.direction,
    s.confidence_score,
    t.profit_loss
FROM signals s
LEFT JOIN LATERAL (
    SELECT profit_loss
    FROM trades
    WHERE signal_id = s.signal_id
    ORDER BY entry_time DESC
    LIMIT 1
) t ON true
WHERE s.created_at >= CURRENT_DATE - INTERVAL '7 days'
ORDER BY s.created_at DESC
LIMIT 50;
```

---

**Document Version**: 1.0  
**Last Updated**: 2024-01-05  
**Next Review**: 2024-02-05